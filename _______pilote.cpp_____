#include <vector>
#include <map>
#include <stdlib.h>
#include <iostream>
#include <assert.h>

/**
 *  Trait for mediator Name.
 *  MUST be defined for each mediator type.
 *  Using Trait is not required but we need something
 *  to get a uniq identifier for each mediator type.
 *  We assume here a total orthogonality between mediator
 *  so that there is no need to register the same mediator twice
 *  with two different identifiers.
 *  (Do so may be done simply with inheritance anyway , as
 *  AbstractMediator::Name is virtual ...)
 **/
template<class T>
struct TraitMediatorName{
	static std::string Name(){return "";}; // nothing means bad ...
};
class Mediator1; // forward decl
template<>
struct TraitMediatorName<Mediator1>{
	static std::string Name(){return "med1";};
};
class Mediator2; // forward decl
template<>
struct TraitMediatorName<Mediator2>{
	static std::string Name(){return "med2";};
};

/**
 *  Abstract mediator container. Encapsulate any type of data.
 *  All data container must inherit from this one.
 *  Note that in some case mediators will probably contains
 *  some functional stuff also, and AbstractCommand::_Execute 
 *  will eventually use those ...
 **/
class AbstractMediator{
	public:
		// is the mediator data ready to be used ?
		enum M_Status{
			M_READY     = 0,
			M_BAD       = 1,
			M_NOT_READY = 2
		};
		AbstractMediator(){};
		virtual ~AbstractMediator(){};
		// is the mediator data ready to be used ?
		virtual M_Status Status() = 0;
		// Init will be called just after the mediator is registered
		virtual bool Init() = 0;
		virtual std::string Name(){return _name;};
   protected:
        std::string _name;
};

/**
 *  Elegant use of CRTP to automatically define Name from Trait
 *  This allows Trait specialization to be done anywhere as soon
 *  as the header is accessible here ...
 **/
template< class T >
class AbstractMediatorBase : public AbstractMediator{ // CRTP
   public:
       AbstractMediatorBase():AbstractMediator(){
          _name = TraitMediatorName<T>::Name();
       }
};

/**
 *  A concrete mediator example.
 **/
class Mediator1 : public AbstractMediatorBase<Mediator1>{
	public:
		Mediator1():AbstractMediatorBase<Mediator1>(){
			toto=0;
			tutu=1;
			bla = "coucou";
			eheh = false;
		};
		~Mediator1(){};
		virtual M_Status Status(){return M_READY;};
		virtual bool Init(){return true;};
	//private:
	public:
		int toto;
		int tutu;
		std::string bla;
		bool eheh;
};

/**
 *  Another concrete mediator example.
 **/
class Mediator2 : public AbstractMediatorBase<Mediator2>{
	public:
		Mediator2():AbstractMediatorBase<Mediator2>(){
			toto=3.14;
			truc=14;
			blabla="youpi";
			b = true;
		};
		~Mediator2(){};
		virtual M_Status Status(){return M_READY;};
		virtual bool Init(){return true;};
	//private:
	public:
		double toto;
		float truc;
		std::string blabla;
		bool b;
};

/**
 *  The DataPool singleton.
 *  Register every Mediator in the DataPool.
 *  Use facade to mix Mediator together and filter them !
 **/
class DataPool{ // singleton
	public:
		~DataPool(){
            _m_it it = _mediators.begin();
            for ( ; it != _mediators.end(); ++it){
                delete it->second;
                it->second = NULL;
            }
        };
		static DataPool * Instance(){
			if( ! _pool ){
				_pool = new DataPool();
			}
			return _pool;
		}
		// Delegate mediator to DataPool
		void Register(AbstractMediator * mediator){
			assert(mediator!=0);
			if ( GetMediator(mediator->Name()) != NULL ){
				std::cout << "Mediator already present in DataPool" << std::endl;
                // HORRIBLE !!!
                // just pay the cost of instanciation and delete it right now !!!
				delete mediator;
				return;
			}
			std::cout << "Registering mediator " << mediator->Name() << std::endl;
			_mediators[mediator->Name()] = mediator;
		}
		AbstractMediator * GetMediator(std::string name){
			if ( _mediators.find( name ) != _mediators.end() ){
				return _mediators[name];
			}
			else{
				return NULL;
			}
		}
		bool Contains(std::string name){ return GetMediator(name)!=NULL;};
	private:
		explicit DataPool(){};
		static DataPool * _pool;
		std::map<std::string,AbstractMediator * > _mediators;
        typedef std::map<std::string,AbstractMediator *>::iterator _m_it;
};

DataPool * DataPool::_pool = NULL;

/**
 *  Abstract facade to DataPool singleton container
 *  Note that this facade shall also be a proxy (think late-init, buffered, access to distant data, ...)
 **/
class AbstractData{
	public:
		AbstractData(){};
		virtual ~AbstractData(){};
		virtual std::string Name() = 0;
};

/**
 *  A concrete facade to DataPool singleton container
 **/
class Data1 : public AbstractData{
	public:
		Data1():AbstractData(){};
		virtual ~Data1(){};
		virtual std::string Name(){return "Data1";};

		double Toto(){
			Mediator2 * med = dynamic_cast<Mediator2*>(DataPool::Instance()->GetMediator(TraitMediatorName<Mediator2>::Name()));
			assert(med!=0);
			return med->toto;
		};
		std::string Bla() {
			Mediator1 * med = dynamic_cast<Mediator1*>(DataPool::Instance()->GetMediator(TraitMediatorName<Mediator1>::Name()));
			assert(med!=0);
			return med->bla;
		};
};

/**
 *  Abstract command, use an AbstractData (facade) to access specified data from DataPool
 *  _Execute must be defined in sub class to implement real stuff ...
 **/
class AbstractCommand{
	public:
		explicit AbstractCommand(AbstractData * d):_d(d){};
		virtual ~AbstractCommand(){};
		bool Execute(){
			assert(_d!=0);
			return _Execute();
		}
	protected:
		virtual bool _Execute() = 0;
		AbstractData * _d;
};

/**
 * A concrete Command using Data1 facade (mix of Mediator1 and Mediator2)
 **/
class Command1 : public AbstractCommand{
	public:
		explicit Command1(Data1 * d):AbstractCommand(d){};
		virtual ~Command1(){};
		virtual bool _Execute(){
			Data1 * d = dynamic_cast<Data1*>(_d);
			assert(d!=0);
			std::cout << "Hello " << d->Name() << std::endl;
			std::cout << "Toto  " << d->Toto() << std::endl;
			std::cout << "Bla   " << d->Bla() << std::endl;
		};
};

/**
 *  Factory of facade
 **/
class DataFactory{
	public:
		enum DataType{
			DT_0 = 0, // forbidden
			DT_1 = 1,
			DT_2 = 2,
			DT_MAX = 2
		};
		static AbstractData * Create(DataType type){
			switch(type){
				case DT_0:
					std::cout << "Error type not defined" << std::endl;
					break;
				case DT_1:
					std::cout << "Creating a Data1" << std::endl;
					return new Data1();
				case DT_2:
					std::cout << "Error non implemented" << std::endl;
					break;
				default:
					std::cout << "Error type unknown" << std::endl;
					break;
			}
			return NULL;
		}
};

/**
 * Factory of command
 **/
class CommandFactory{
	public:
		enum CommandType{
			CT_0 = 0, // forbidden
			CT_1 = 1,
			CT_2 = 2,
			CT_MAX = 2
		};
		static AbstractCommand * Create(AbstractData * d, CommandType type){
			switch(type){
				case CT_0:
					std::cout << "Error type not defined" << std::endl;
					break;
				case CT_1:
					{
						Data1* dd = dynamic_cast<Data1*>(d);
						if (dd){
							std::cout << "Creating a Command1" << std::endl;
							return new Command1(dd);
						}
						std::cout << "Error bad data type for Command1" << std::endl;
					}
					break;
				case CT_2:
					std::cout << "Error non implemented" << std::endl;
					break;
				default:
					std::cout << "Error type unknown" << std::endl;
					break;
			}
			return NULL;
		}
};

/**
 *  Factory of mediator
 **/
class MediatorFactory{
	public:
		static std::vector<AbstractMediator *> Create(DataFactory::DataType type){
			switch(type){
				case DataFactory::DT_0:
					std::cout << "Error type not defined" << std::endl;
					break;
				case DataFactory::DT_1:
					{
						std::cout << "Registering mediators for Data1" << std::endl;
						std::vector<AbstractMediator *> ret;
						// this one needs interact with two mediators ...
						if ( ! DataPool::Instance()->Contains(TraitMediatorName<Mediator1>::Name()) ){
							DataPool::Instance()->Register(new Mediator1());
							ret.push_back(DataPool::Instance()->GetMediator(TraitMediatorName<Mediator1>::Name()));
						}
						if ( ! DataPool::Instance()->Contains(TraitMediatorName<Mediator2>::Name()) ){
							DataPool::Instance()->Register(new Mediator2());
							ret.push_back(DataPool::Instance()->GetMediator(TraitMediatorName<Mediator2>::Name()));
						}
						return ret;
					}
				case DataFactory::DT_2:
					std::cout << "Error non implemented" << std::endl;
					break;
				default:
					std::cout << "Error type unknown" << std::endl;
					break;
			}
			return std::vector<AbstractMediator *> ();
		}
};


namespace Pilot{
	/**
	 * Abstract Pilot builder ...
	 **/
	std::vector<AbstractCommand*> Build(std::vector<DataFactory::DataType> datas, std::vector<CommandFactory::CommandType> commands){
		assert(datas.size() == commands.size());
		std::vector<AbstractCommand*> ret;
		for(int k = 0 ; k < datas.size() ; ++k){
			AbstractData *    d = DataFactory::Create(datas[k]);
			if ( !d ){
				std::cout << "Error data not built" << std::endl;
				return std::vector<AbstractCommand*>();
			}
			AbstractCommand * c = CommandFactory::Create(d,commands[k]);
			if ( !c ){
				std::cout << "Error command not built" << std::endl;
				return std::vector<AbstractCommand*>();
			}
			ret.push_back(c);
		}
		return ret;
	}

	/**
	 * Register all needed mediators for a given DataType
	 **/
	void RegisterMediators(std::vector<DataFactory::DataType> datas){
		for(int k = 0 ; k < datas.size() ; ++k){
			std::vector<AbstractMediator*> mediators = MediatorFactory::Create(datas[k]);
			for (int m = 0 ; m < mediators.size(); ++m){
				std::cout << "Init mediator " + mediators[m]->Name() << std::endl;
				if ( ! mediators[m]->Init() ){
					std::cout << "Fail to init mediator " + mediators[m]->Name() << std::endl;
				}
			}
		}
	}
} // Pilot

int main(int argc,char ** argv){
	std::vector<DataFactory::DataType> datas;
	std::vector<CommandFactory::CommandType> commands;
	datas.push_back(DataFactory::DT_1);
	commands.push_back(CommandFactory::CT_1);

	Pilot::RegisterMediators(datas);
	std::vector<AbstractCommand*> tasks = Pilot::Build(datas,commands);
	for(int k = 0 ; k < tasks.size(); ++k){
		tasks[k]->Execute();
	}
	return 0;
}
